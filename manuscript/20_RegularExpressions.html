<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta charset="utf-8">
<meta name="author" content="Kai Jaeger">
<title>Direct input</title>
<style media="screen">
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block;}audio,canvas,progress,video{display:inline-block;vertical-align:baseline;}audio:not([controls]){display:none;height:0;}[hidden],template{display:none;}a{background-color:transparent;}a:active,a:hover{outline:0;}abbr[title]{border-bottom:1px dotted;}b,strong{font-weight:bold;}dfn{font-style:italic;}h1{font-size:2em;margin:0.67em 0;}mark{background:#ff0;color:#000;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sup{top:-0.5em;}sub{bottom:-0.25em;}img{^border:0;}svg:not(:root){overflow:hidden;}figure{margin:1em 40px;}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0;}code,kbd,pre,samp{font-family:APLFont;font-size:1em;}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0;}button{overflow:visible;}button,select{text-transform:none;}button,html input[type="button"], input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer;}button[disabled],html input[disabled]{cursor:default;}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}input{line-height:normal;}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto;}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box;}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em;}legend{border:0;padding:0;}textarea{overflow:auto;}optgroup{font-weight:bold;}table{border-collapse:collapse;border-spacing:0;}td,th{padding:0;}body{margin:0pt 0pt 0pt 0pt;font-family:'Verdana', serif;background-color:#fdfdfd;font-size:18px;line-height:1.4;max-width:900px;padding:15px;}h1, h2, h3, h4, h5, h6{color:Black;font-weight:800;padding-left:0;font-family:'Arial';}h1, h2, h3, h4, p{margin-bottom:16px;}h1{font-size:32px;margin:5px 0 20px 0;}h1 > code, h2 > code, h3 > code, h4 > code, h5 > code, h6 > code{font-size:100%;background-color:inherit;}h2{font-size:26px;margin:10px 0 10px 0;padding-top:10px;border-bottom:1px solid Black;}h3{margin:0; margin-top:10px;font-size:22px;}h4{font-size:18px;margin:0;margin-top:10px;}h5, h6{font-size:16px;margin:0;margin-top:12px;padding:0;}a{color:#0099ff;margin:0;padding:0;vertical-align:baseline;}a:visited{color:purple;}a.autoheader_anchor{text-decoration:none;}ul{list-style-type:disc;}ul, ol{padding:0;margin:0;}li > ul, ol{padding-bottom:0;}li{line-height:1.3;margin-left:25px;margin-bottom:10px;}ul > li{margin-left:20px;}li ul{margin-left:10px;}li ul{margin-left:5px;}li p{padding:1px 0 0 0; margin:10px 0 5px 0;line-height:1.3;}p, ul, ol{line-height:1.3;padding:8px 0 0 0;margin:0;color:#505050;}pre{overflow:auto;padding:10px 5px;margin:10px 0 10px 0 !important;white-space:pre-wrap;background-color:#e7e7e7;color:#3e3e3e;border:1px Silver dashed;display:block;font-family:APLFont, monospace;font-weight:400;}pre > code{line-height:1.2;border:0;padding:0;margin:0;background-color:inherit;color:inherit;font-weight:inherit;}li > pre{left-margin:0;}nav code{background-color:inherit;}code{font-family:APLFont, monospace;background-color:#e7e7e7;color:Black;font-weight:800;line-height:1.2;font-size:16px;margin:0;padding:3px 8px 3px 8px;}tbody th, tfoot tr{background-color:silver;}tbody tr:nth-child(odd){background-color:#f5f5f5;}th, td{padding:3px 10px;}table{border-color:Black;background-color:#ebebeb;margin:20px 0 20px 0;border:2px black;border-collapse:collapse;font-family:APLFont;font-size:16px;line-height:1.2;border:1pt solid Gray;}li > table{margin:10px 0 10px 0;}tr{margin:20px;}th{font-weight:bold;}tfoot td{font-weight:bold;}blockquote{border-left:5px solid silver;padding-left:5px;margin:15px 5px 15px 10px;}blockquote ul li{margin-left:215px;}blockquote ol li{margin-left:25px;}li > blockquote{margin-left:0;}nav{background-color:#f5f5f5;border:1px solid Black;padding:10px;margin:10px;margin-right:0;box-shadow:5px 5px 5px Gray; float:right;width:auto;}nav code{font-size:80%;}nav#main_nav{position:fixed;top:0;right:10px;float:none;}nav ul{list-style-type:none; margin:0 0 2px 0;padding:0;}nav a:visited{ color:black;}nav ul li{margin-bottom:0px;}nav li p{margin:0;padding:0;line-height:1;margin:0;padding:0;}nav li{font-size:11px;line-height:1.3;padding:0;margin-top:0;margin-bottom:0;margin-left:15px;}nav p{font-weight:bold;font-size:75%;padding-top:0;}dl{margin-top:0.1em;margin-bottom:0.1em;}dt{margin-top:0.75em;margin-bottom:0.1em;font-weight:800;}label#hide_toc_label{font-size:80%;}.toc-container{position:relative;height:auto;}[type="checkbox"]{position:absolute;left:-9999px;}label{display:block;width:100%;height:1.1em;cursor:pointer;top:0;padding-left:10pt;}label:before{content:'Table of contents (Show)';font-weight:bold;font-size:90%;padding-bottom:0pt;}[type="checkbox"] ~ div{display:none;}[type="checkbox"]:checked ~ div{display:block;margin-top:10pt;}[type="checkbox"]:checked + label{top:100%;}[type="checkbox"]:checked + label:before{content:'Table of contents (Hide)';}.print_only{display:none;}div#footnotes_div p{line-height:1; padding-bottom:0;padding-top:0;}div#footnotes_div ol{padding-top:0;}@font-face{font-family:"APLFont";src:local("APL385 Unicode"), url("http://misc.aplteam.com/apl385.ttf") format("truetype");}
</style>
<style media="print">
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;}body{-webkit-print-color-adjust:exact;}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block;}audio,canvas,progress,video{display:inline-block;vertical-align:baseline;}audio:not([controls]){display:none;height:0;}[hidden],template{display:none;}a{background-color:transparent;}a{color:black !important;text-decoration:none;}a:active,a:hover{color:black;outline:0;}b,strong{font-weight:bold;}dfn{font-style:italic;}h1{margin:0.67em 0;}mark{background:#ff0;color:#000;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sup{top:-0.5em;}sub{bottom:-0.25em;}img{border:0;}svg:not(:root){overflow:hidden;}figure{margin:1em 40pt;}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0;}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em;}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0;}button{overflow:visible;}button,select{text-transform:none;}button,html input[type="button"], input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer;}button[disabled],html input[disabled]{cursor:default;}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}input{line-height:normal;}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto;}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box;}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none;}fieldset{border:1pt solid #c0c0c0;margin:0 2pt;padding:0.35em 0.625em 0.75em;}legend{border:0;padding:0;}textarea{overflow:auto;}optgroup{font-weight:bold;}table{border-collapse:collapse;border-spacing:0px;}td, th{padding:2pt 8pt;}body{margin:10pt 0 0 0;font-family:"Bookman Old Style", serif;background-color:#fdfdfd;font-size:9pt;line-height:1.2;max-width:auto;padding:15pt;}h1, h2, h3, h4 h5 h6{color:black;font-weight:800;padding-left:0;margin:5pt 0 0 0;padding:0}h1, h2, h3, h4, p{margin-bottom:5pt;}h1 > code, h2 > code, h3 > code, h4 > code, h5 > code, h6 > code{font-size:100%;}h1{font-size:170%;margin-top:25pt;margin-bottom:10pt;}h2{font-size:135%;margin:15pt 0 10pt 0;border-bottom:1pt solid Silver;}h3{font-size:125%;}h3, h4 > pre{margin-bottom:8pt;}h4{font-size:115%;}h5{font-size:105%;padding-bottom:0;margin-bottom:0;}h5{font-size:100%;}a{color:#0099ff;margin:0;padding:0;vertical-align:baseline;}a.autoheader_anchor{text-decoration:none;}ul{list-style-type:square;}ul, ol{padding:0;margin:0;}li > ul, ol{padding-bottom:0;}li{line-height:1.3;margin-left:13pt;margin-bottom:5pt;}ul > li{margin-left:10pt;}li ul{margin-left:5pt;}li ul{margin-left:3pt;}li p{padding:1pt 0 0 0; margin:5pt 0 3pt 0;line-height:1.3;}p, ul, ol{line-height:1.3;padding:4pt 0 0 0;margin:0;color:#292929;}pre{padding:3pt;margin:5px 0;white-space:pre-wrap; background-color:#f8f8f8; background-color:#f0f0f0;border:1pt Silver solid;display:block;font-family:APLFont, monospace;font-weight:800;overflow:auto;}pre code{ background-color:#f0f0f0; color:Black; padding:0; margin:0 0 -6pt 0; line-height:1.1; border:0;}code{font-family:APLFont, monospace;font-weight:800;line-height:1.2;font-size:8pt;color:#950000;padding:3pt 4pt 3pt 4pt;}tbody th, tfoot tr{background-color:silver;}tbody tr:nth-child(odd){background-color:#fafafa;}th, td{padding:1pt 5pt;}table{background-color:#f1f1f1;margin:20pt 0;font-family:APLFont;font-size:8pt;padding:3pt 5pt;border:1pt solid silver;page-break-inside:avoid;}li > table{margin:10pt 0 10pt 0;}tr{margin:20pt;}th{font-weight:bold;}tfoot td{font-weight:bold;}blockquote{border-left:5pt solid silver;padding-left:5pt;margin:8pt 3pt 8pt 8pt;}nav{background-color:#f8f8f8;border:1pt solid Gray;width:auto; float:right;padding:5pt 5pt 5pt 0;margin:5pt 0 5pt 5pt;}nav *{font-size:75%;}nav ul{list-style-type:none; margin:0 0 2px 0;padding:0;}nav ul li{margin-bottom:0px;}nav li p{margin:0;padding:0;line-height:1;margin:0;padding:0;}nav li{font-size:8pt;line-height:1;padding:0;margin-top:0;margin-bottom:0;margin-left:15px;}dl{margin-top:0.1em;margin-bottom:0.1em;}dt{margin-top:0.1em;margin-bottom:0.75em;font-weight:800;}label#hide_toc_label{font-size:65%;}.toc-container{position:relative;height:auto;margin-top:10pt;}[type="checkbox"]{display:none;}label{display:block;width:100%;height:1.1em;top:0;padding-left:10pt;}label:before{content:'Table of contents (Show)';font-weight:bold;font-size:140%;padding-bottom:10pt;}a.external_link::before{content:" 🌎";}a.bookmark_link::before{content:" ➯";}a.bookmark_link{font-style:italic;}a.mailto_link::before{content:" ✉"}nav a.bookmark_link{font-style:normal;}nav p{margin-left:10pt;font-weight:bold;font-size:10pt;}nav a.bookmark_link::before{content:"";}div#footnotes_div a::before{content:"";}div#footnotes_div a{font-style:normal;}@font-face{font-family:"APLFont";src:local("APL385 Unicode"), url("http://misc.aplteam.com/apl385.ttf") format("truetype");}
</style>
</head>
<body>
<p>{:: encoding=“utf-8” /}</p>
<a href="#regular-expressions-with-dyalog" id="regular-expressions-with-dyalog" class="autoheader_anchor">
<h1>Regular expressions with Dyalog</h1>
</a>
<a href="#to-whom-it-concerns" id="to-whom-it-concerns" class="autoheader_anchor">
<h2>To whom it concerns</h2>
</a>
<p>If you are fluent in regular expressions then you may skip this chapter except perhaps “Analyzing APL ocde” which might tell you about a particular strength of Dyalog's implementation of regular expressions.</p>
<p>If you are not fluent in regular expression but heavily involved into number crunching without any memory of ever having scanned strings for certain patterns then there is no point in looking into regular expressions because you just don't need them. Let's be clear, regular expressions are an extremely powerful tool, but the level of abstraction is really high. You will find it hard to master them without using them regularly. To rephrase it, if you need to find a pattern in a string twice a year you are probably better off finding an expert on the matter you can ask for advice.</p>
<p>Having said this it is amazing that many APLers do not realize how often they actually do search for strings and patterns.</p>
<a href="#overview" id="overview" class="autoheader_anchor">
<h2>Overview</h2>
</a>
<p>In this chapter we take the approach to explain regular expressions purely by example. The examples start simple and grow complex. Along the line we introduce more features of regular expressions in general and Dyalog's implementation in particular. Your best strategy is to read the following stuff from start to end. It will introduce you to the basic concepts and provide you with the necessary knowledge to become a keen amateur. From there constant usage of regular expressions and the Internet will convert you into an expert, though it will take a bit of time and effort. Be assured that it will be well invested time.</p>
<p>This chapter is by no means a comprehensive introduction to regular expressions, but it should get you to a point where you can take advantage of examples, documents and books that are not addressing Dyalog's implementation.</p>
<p>Note that we explain the syntax of <code>⎕S</code> and <code>⎕R</code> separately from the main text. That makes it easy to ignore those bits in case you are already familiar with the syntax.</p>
<p>Despite the name of the book you will find only very few recipes for real-world problems in this chapter. The problems provided are used as vehicles to introduce the main features of regular expressions.</p>
<a href="#what-are-regular-expressions" id="what-are-regular-expressions" class="autoheader_anchor">
<h2>What are regular expressions?</h2>
</a>
<p>Regular expressions allow you to find the position of a search string in another string. They also allow you to replace a string by another one.</p>
<a href="#background" id="background" class="autoheader_anchor">
<h2>Background</h2>
</a>
<p>Dyalog is using the PCRE implementation of regular expressions. This library attempts to stay as close as possible to the Perl 5 implementation. There are many other implementations available, and they all differ more or less. Therefore it is important to know what kind of engine you are actually using when you do RegExes from within Dyalog. Dyalog 16.0 uses PCRE version 8. Note that PCRE is considered one the most complete and powerful implementations of regular expressions.</p>
<a href="#examples" id="examples" class="autoheader_anchor">
<h2>Examples</h2>
</a>
<a href="#example-1---search-a-string-in-a-string" id="example-1---search-a-string-in-a-string" class="autoheader_anchor">
<h3>Example 1 - search a string in a string</h3>
</a>
<pre><code>      ⍴'notfound' ⎕s 0⊣ 'the cat sat on the medallion'
0
      'cat' ⎕s 0⊣ 'the cat sat on the medallion'
 4</code></pre>
<p>A&gt; ### The right operand and the right argument A&gt; A&gt; <code>⎕S</code> is, like <code>⎕R</code>, an <em>operator</em>. An operator takes either just a left operand (monadic) or a left and right operand (dyadic) and forms a so-called derived function. For example, the operator <code>/</code> when fed with a left operand <code>+</code> forms the derived function “sum”. A&gt; A&gt; In the example the <code>0</code> is the right operand. With <code>⎕S</code> the right operand can be one to many of 0, 1, 2 and 3 (those are called transformation codes) or a user defined function which is explained later. A&gt; A&gt; * <code>0</code> stands for: offset from the start of the line to the start of the match. A&gt; * <code>1</code> stands for: length of the match. A&gt; A&gt; A&gt; The transformation codes <code>2</code> and <code>3</code> will be discussed later. A&gt; A&gt; The right argument provided to the derived function is the string <code>'the cat sat on the medallion'</code>. The operand and the string are separated by the <code>⊣</code> function. Instead we could have used parenthesis with exactly the same result: <code>('notfound' ⎕s 0) 'the cat sat on the medallion'</code>.</p>
<p>In the first expression the result is empty because the string <code>notfound</code> was not found. In the second expression <code>cat</code> was actually found. That means that we could say:</p>
<pre><code>      'cat' {⍵↓⍨⍺ ⎕s 0 ⊣ ⍵}'the cat sat on the medallion'
cat sat on the medallion</code></pre>
<p>That was easy, wasn't it! Obviously regular expressions are nothing to be afraid off. Let's look at another example: find out what's between double quotes. First attempt:</p>
<pre><code>      '"' ⎕S 0 ⊣ 'He said "Yes"'
 8 12</code></pre>
<p>That gives us the offset of the two double quotes, but what if we want to have the offset and the length of any string found <em>between</em> — and including — the double quotes? For that we need to introduce the <em>meta character</em> dot (<code>.</code>) which has a special meaning in a regular expression: it represents <em>any</em> character (not strictly true but we will soon discuss the exception, the NewLine character).</p>
<p>A&gt; ### Meta Characters A&gt; A&gt; Meta characters, sometimes called special characters, are those characters that have a special meaning in a regular expression. In order to really master regular expressions you have to know <em>all of them</em>. That will not only enable you to use them properly, it will also prevent you from advertising yourself as a non-skilled RegEx user: those tend to escape pretty much everything that is not a letter or a digit because they don't know what they are doing. Even if you don't care, unnecessary escaping also reduces readability significantly; you really should only escape the characters that really <em>need</em> escaping. A&gt; A&gt; Note that if you want a meta character to be taken literally (like searching for a dot) then you have to escape the meta character by a backslash (<code>\</code>) which therefore is itself a meta character. The expression <code>'"\.\\"'</code> would search for double-quote followed by a single dot followed by a single backslash followed by a double-quote.</p>
<p>So we try:</p>
<pre><code>      '"."' ⎕S 0 1 ⊣ 'He said "Yes"'
</code></pre>
<p>Opps - no hit.</p>
<p>In order to understand this we have to know <em>exactly</em> what the regular expression engine did:</p>
<ol start="1">
<li>It starts at the beginning of the string; that is actually one to the left of the initial “t”! That position can only match to the meta character <code>^</code> which represents the start of a line.</li>
<li>If there is no match the engine forgets about it and moves one character forward. This is called “consuming” the position the engine has looked at.</li>
<li>It then tries to match <code>"</code> to <code>H</code>. Since there is no match either…</li>
<li>It carries on until it arrives at the <code>"</code>. Now there is a match!</li>
<li>The engine now tries to match the <code>.</code> against the <code>Y</code>. Since the<code>.</code> matches <em>any</em> character this is a match, too.</li>
<li>It then moves forward one more character and tries to match the <code>"</code> with <code>e</code> - that's <em>not</em> a match.</li>
<li>The engine forgets what it has done, goes back to where it started from (that was the <code>"</code>) and moves one character forward.</li>
<li>It now tries to  match the <code>"</code> with the <code>Y</code> …</li>
</ol>
<p>You can now see why it does not report any hit - it would work on <code>'He said "Y"'</code> or more generally, on any single character that is embraced by two double quotes.</p>
<p>What we need is a way to tell the engine that it should try to match the <code>.</code> more than once. There is a general way of doing this and three shortcuts that cover most cases. For example, in order to match a minimum of one to a maximum of three underscore characters:</p>
<pre><code>      '_{1,3}' ⎕S 0 ⊢'_one__two___three____four'
0 4 9 17 20</code></pre>
<p>It is actually easier to check the result by replacing the hits with something outstanding:</p>
<pre><code>      '_{1,3}' ⎕R '⌹' ⊢'_one__two___three____four'
⌹one⌹two⌹three⌹⌹four
      '_{2,3}' ⎕R '⌹' ⊢'_one__two___three____four'
_one⌹two⌹three⌹_four</code></pre>
<p>A&gt; ### The right operand A&gt; A&gt; <code>⎕R</code> takes one or more replace strings <em>or</em> a user defined function (discussed later) as the right operand; you cannot mix replace strings with user defined functions.</p>
<p>What's between the curlies (<code>{}</code>) – which are meta characters as well – defines how many are required as minimum and maximum. This is called a quantifier.</p>
<ul>
<li><code>{x,y}</code> means a min of x and a max of y.</li>
<li><code>{,y}</code> is the same as <code>{0,y}</code>.</li>
<li><code>{x,}</code> means a min of x with no max limit.</li>
<li><code>{x}</code> means exactly x.</li>
</ul>
<p>Then there are the shortcuts that make life a bit easier:</p>
<ul>
<li>The star (<code>*</code>) is a shortcut for <code>{0,y}</code> and <code>{,y}</code>.</li>
<li>The plus (<code>+</code>) is a shortcut for <code>{1,}</code>.</li>
<li>The question mark (<code>?</code>) is a shortcut for <code>{0,1}</code>.</li>
</ul>
<p>Therefore:</p>
<pre><code>      '".*"' ⎕R '⌹' ⊣ 'He said "Yes"!'
He said ⌹!</code></pre>
<pre><code>      '".*"' ⎕R '⌹' ⊣ 'He said "Yes" and "No"!'
He said ⌹!</code></pre>
<p>Just one hit, and that hit spans <code>"Yes" and "No"</code>?! That's because by default the engine is <em>greedy</em> as opposed to <em>lazy</em>: it carries on and tries to match the <code>.</code> against as many characters as it can. That means that in our example it will stop only after it reached the end of the line, because all characters found are a match. It would then go back until it finds a <code>"</code> (coming from the right!) and then stop because it's done the job.</p>
<p>The same is true for the <code>{x,y}</code> quantifiers: by default they are all <em>greedy</em> rather than <em>lazy</em>, so repeating <code>y</code> times is tried before reducing the repetition to <code>x</code> times.</p>
<p>What we need instead is a <em>lazy</em> search, therefore:. We can change the default by specifying the “Greedy” option:</p>
<pre><code>      '".*"' ⎕R '⌹' ⍠('Greedy' 0) ⊣ 'He said "Yes" and "No"!'
He said ⌹ and ⌹!</code></pre>
<p>A&gt; ### Options A&gt; A&gt; Between the right operand and the right argument you may specify options. They are marked by the <code>⍠</code> operator. These are the options available: A&gt; A&gt; IC, Mode, DotAll, EOL, ML, Greedy, OM, InEnc, OutEnc, Enc, ResultText, UCP A&gt; A&gt; Note that “IC” is the principle option. That means that if no other option needs to be specified you can omit the “IC”; this would do: <code>⎕S 0 ⍠ 1 ⊢ 'whatever'</code>. “IC” stands for “Ignore Case”. A 1 would make a search pattern case insensitive. The default is 0. A&gt; A&gt; In this chapter we won't discuss all these options but “IC”, “Mode”, “DotAll”, “Greedy” and “UCP”. For the others refer to <code>⎕R</code>'s help page.</p>
<p>But wouldn't it be better to use the <code>+</code> rather than the <code>*</code> here? After all we are not interested in <code>""</code> because their is nothing between the two double quotes? Good point except it does not work:</p>
<pre><code>      '".+"' ⎕R '⌹' ⍠('Greedy' 0) ⊣ 'He said "" and ""'
He said ⌹"</code></pre>
<p>That because the engine would perform the following steps:</p>
<ol start="1">
<li>Investigate until we find a <code>"</code>.</li>
<li>Investigate any character after the first double quote. That is the scond double quote so <em>that is consumed</em> becaue it required <em>at least one</em>. Since all other characters are a match as well the <code>.+</code> consumes all characters to the end of the input string.</li>
<li>It then goes back the the current position — because it is lazy! — which is bacause the second <code>"</code> was already consumed the space after (!) the second <code>"</code> and before the <code>a</code> of “and”. From there it carries on until it finds a <code>"</code>. That is first <code>"</code> after the “and”. All that is then relpaced by the <code>⌹</code> character.</li>
<li>The engine then carries on but because there is only a single <code>"</code> left there is no other match.</li>
</ol>
<p>What we need is called <em>permissive</em>.</p>
<p>⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹</p>
<p>Apart from delivering the desired result permissive quantifiers have a another advantage: they don't remember any backtracking positions. Therefore they should be faster. Let's check this. Fire up a Dyalog session with 512MB workspace size, issue the command <code>)copy dfns cmpx</code> and the define this input string:</p>
<pre><code>      is←'123 ',(200000000⍴⎕D),' 123'</code></pre>
<p>Now we can execute both versions, the lazy and the permissive one. Since the permissive one does not store backtracking references it should be considerably faster:</p>
<pre><code>      cmpx '''\b\d+\b''⎕S 0⍠(''Greedy'' 0)⊣ #.is' '''\b\d++\b''⎕S 0⍠(''Greedy'' 0)⊣ #.is'
  '\b\d+\b'⎕S 0⍠('Greedy' 0)⊣ #.is  → 5.4E0  |   0% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
  '\b\d++\b'⎕S 0⍠('Greedy' 0)⊣ #.is → 2.8E0  | -48% ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕</code></pre>
<p>Roughly twice as fast.</p>
<p>Let's repeat our findings because this is so important:</p>
<ul>
<li>Greedy means match <em>longest</em> possible string.</li>
<li>Lazy means match <em>shortest</em> possible string.</li>
</ul>
<a href="#garbage-in-garbage-out" id="garbage-in-garbage-out" class="autoheader_anchor">
<h3>Garbage in, garbage out</h3>
</a>
<p>Let's modify the input string:</p>
<pre><code>      is←'He said "Yes"" and "No"'  ⍝ define "input string"</code></pre>
<p>There are <em>two</em> double quotes after the word “Yes”; that seems to be a typo. Watch what our RegEx is making of this:</p>
<pre><code>      '".*"' ⎕R '⌹' ⍠('Greedy' 0) ⊣ is
 He said ⌹⌹No"</code></pre>
<p>This example highlights a potential problem with input strings: many regular expressions work perfectly well as long as the input string is, well, let's say syntactically correct. That's (among other reasons) why regular expressions are not recommended for processing HTML because HTML is very often full of syntactical errors. However, if you can be certain that the HTML you have to deal with <em>is</em> syntactically correct <em>and</em> the piece of HTML is short then there is nothing wrong with using regular expressions to process it.</p>
<p>A&gt; ### Regular expressions and HTML A&gt; A&gt; There are claims that you <em>cannot</em> parse HTML with regular expressions because a regular expression engine is a Finite Automata while HTML can be nested indefinitely. This is partly wrong and partly misleading. A&gt; A&gt; * It is wrong because today's regular expression engines come with features (back referencing) that are clearly beyond the feature set of a Finite Automata. A&gt; * It is misleading because it ignores that regular expression engines are perfectly capable of processing small pieces of HTML that are known to be syntactically correct.</p>
<p>By now we've met quite a number of meta characters; how many do we have to deal with? Well, quite a lot:</p>
<table>
<thead>
<tr>
<th style="text-align: right;">   </th>
<th style="text-align: left;"> Meta character               </th>
<th style="text-align: left;"> Symbol </th>
<th style="text-align: left;"> </th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1.</td>
<td>Backslash</td>
<td><code>\</code></td>
<td>✔</td>
<td>Escape character</td>
</tr>
<tr>
<td style="text-align: right;">2.</td>
<td>Caret</td>
<td><code>^</code></td>
<td>✔</td>
<td>Start of line</td>
</tr>
<tr>
<td style="text-align: right;">3.</td>
<td>Dollar sign</td>
<td><code>$</code></td>
<td></td>
<td>End of line</td>
</tr>
<tr>
<td style="text-align: right;">4.</td>
<td>Period or dot</td>
<td><code>.</code></td>
<td>✔</td>
<td>Any character but NewLine</td>
</tr>
<tr>
<td style="text-align: right;">5.</td>
<td>Pipe symbol</td>
<td><code>|</code></td>
<td></td>
<td>Logical “OR”</td>
</tr>
<tr>
<td style="text-align: right;">6.</td>
<td>Question mark</td>
<td><code>?</code></td>
<td></td>
<td>Extends meaning of <code>(</code>; 0 or 1 quantifier (=optional); make it lazy</td>
</tr>
<tr>
<td style="text-align: right;">7.</td>
<td>Asterisk or star</td>
<td><code>*</code></td>
<td>✔</td>
<td>Repeat 0 to many times</td>
</tr>
<tr>
<td style="text-align: right;">8.</td>
<td>Plus sign</td>
<td><code>+</code></td>
<td>✔</td>
<td>Repeat 1 to many times</td>
</tr>
<tr>
<td style="text-align: right;">9.</td>
<td>Opening parenthesis</td>
<td><code>(</code></td>
<td></td>
<td>Start sub pattern</td>
</tr>
<tr>
<td style="text-align: right;">10.</td>
<td>Closing parenthesis</td>
<td><code>)</code></td>
<td></td>
<td>End sub pattern</td>
</tr>
<tr>
<td style="text-align: right;">11.</td>
<td>Opening square bracket</td>
<td><code>[</code></td>
<td></td>
<td>Start character class (or set)</td>
</tr>
<tr>
<td style="text-align: right;">12.</td>
<td>Opening curly brace</td>
<td><code>{</code></td>
<td>✔</td>
<td>Start min/max quantifier</td>
</tr>
</tbody>
</table>
<p>By now we have already discussed six of them; they carry a check mark.</p>
<p>Note that both <code>}</code> and <code>]</code> are considered meta characters only after an opening <code>{</code> or <code>[</code>. Without the opening counterpart they are taken literally; that's why they did not make it into the list of meta characters.</p>
<a href="#example-2---digits-in-a-string" id="example-2---digits-in-a-string" class="autoheader_anchor">
<h3>Example 2 - digits in a string</h3>
</a>
<p>Let's assume we want to match all digits in a string:</p>
<pre><code>      '[0123456789]'⎕R '⌹' ⊣ 'It''s 23.45 plus 99.12.'
It's ⌹⌹.⌹⌹ plus ⌹⌹.⌹⌹.</code></pre>
<p>Everything between the <code>[</code> and the <code>]</code> is treated as a simple character - with a few exceptions we'll soon discuss. That makes both <code>[</code> and <code>]</code> meta characters.</p>
<p>The same but shorter:</p>
<pre><code>      '[0-9]'⎕R '⌹' ⊣ 'It''s 23.45 plus 99.12.'
It's ⌹⌹.⌹⌹ plus ⌹⌹.⌹⌹.</code></pre>
<p>Note that the minus is treated as a meta character here: it means “all digits from 0 to 9”.</p>
<p>Even shorter:</p>
<pre><code>      '\d'⎕R '⌹' ⊣ 'It''s 23.45 plus 99.12.'
It's ⌹⌹.⌹⌹ plus ⌹⌹.⌹⌹.</code></pre>
<p>Note that the meta character backslash (<code>\</code> ) is used for two different purposes:</p>
<ul>
<li>To escape any of the RegEx meta characters so that they are stripped of their special meaning and taken literally.</li>
<li>To give the next character a special meaning in case it is an ordinary ASCII letter.</li>
</ul>
<p>So <code>\*</code> takes away the special meaning from the <code>*</code> while <code>\d</code> gives the <code>d</code> the special meaning “all digits”.</p>
<p>We take the opportunity to add the dot (<code>.</code>) and the minus (<code>-</code>) to the character class. Note that the minus is not escaped; from the context the regular expression engine can work out that here the minus cannot mean from-to, so it is taken literally.</p>
<pre><code>      '[\d.-]'⎕R '⌹' ⊣ 'It''s 23.45 plus -99.12.'
It's ⌹⌹⌹⌹⌹ plus ⌹⌹⌹⌹⌹⌹⌹</code></pre>
<p>Here we have another problem: we want the dot only to be a match when there is a digit to both the left and the right of the dot. Our search pattern is not dealing with this, therefore the trailing <code>.</code> is a match. We will tackle this problem soon with look-ahead and look-behind.</p>
<p>Character classes work for letters as well:</p>
<pre><code>      '[a-zA-Z]'⎕R '⌹' ⊣'It''s 23.45 plus 99.12.'
⌹⌹'⌹ 23.45 ⌹⌹⌹⌹ 99.12.</code></pre>
<p>We can negate with <code>^</code> right after the opening <code>[</code>:</p>
<pre><code>    '[^a-zA-Z]'⎕R '⌹' ⊣'It''s 23.45 plus 99.12.'
It⌹s⌹⌹⌹⌹⌹⌹⌹plus⌹⌹⌹⌹⌹⌹⌹</code></pre>
<p>Notes:</p>
<ul>
<li>The <code>^</code> has a different meaning in a character class definition. Outside character classes it stands for “Start of line” as mentioned earlier.</li>
<li>Only at the beginning of a character class definition has the caret the meaning “negate”. Therefore you could also say that <code>[^</code> means “negate” while, say, <code>[1^2]</code> means "Match for one of these three characters: <code>1^2</code>.</li>
<li>For APLers the caret is a bit tricky because it can easily be confused with the logical AND (<code>∧</code>) function. Only next to each other it becomes apparent what it what: <code>^∧</code>: the caret is a bit higher than the logical AND.</li>
</ul>
<p>I&gt; Many problems can be solved in more than one way with regular expressions. For example, our earlier problem to find everything between (and including) double quotes can be solved with this expression as well: <code>'"[^"]*"' ⎕R '⌹' ⊣ 'He said "Yes", she said "No".'</code>. It matches a double quote, then as many characters as possible that are <em>not</em> a double quote and finally the closing double quote. This expression has the advantage of not depending on the setting of the “Greedy” option.</p>
<p>Negate with digits and dots:</p>
<pre><code>      '[^.0-9]'⎕R '⌹' ⊣'It''s 23.45 plus 99.12.'
⌹⌹⌹⌹⌹23.45⌹⌹⌹⌹⌹⌹99.12.</code></pre>
<p>Want to search for “gray” and “grey” in a document?</p>
<pre><code>      'gr[a|e]y'⎕S 0⊣'Americans spell it "gray" and Brits "grey".'
20 37
      'gr[a|e]y'⎕R '⌹' ⊣'Americans spell it "gray" and Brits "grey".'
Americans spell it "⌹" and Brits "⌹".</code></pre>
<p>So the pipe symbol (<code>|</code>) has a special meaning inside a character class: it means logical “OR”.</p>
<p>Note that there are only a few meta characters inside character classes:</p>
<table>
<thead>
<tr>
<th style="text-align: left;"> Meta character    </th>
<th style="text-align: left;"> Symbol </th>
<th style="text-align: left;"> Meaning                    </th>
</tr>
</thead>
<tbody>
<tr>
<td>Closing bracket</td>
<td><code>]</code></td>
<td></td>
</tr>
<tr>
<td>Backslash</td>
<td><code>\</code></td>
<td>Escape next character</td>
</tr>
<tr>
<td>Caret</td>
<td><code>^</code></td>
<td>Negate the character class</td>
</tr>
<tr>
<td>Minus</td>
<td><code>-</code></td>
<td>From-to</td>
</tr>
</tbody>
</table>
<p>We already worked out that the engine is smart enough to take a minus literally when it makes an appearance somewhere where it cannot mean from-to: the beginning and the end of a character class. Similarly the caret (<code>^</code>) character can only negate a character class as a whole, when it follows the opening square bracket (<code>[^</code>). If the caret is specified elsewhere it is taken literally. Therefore the expression <code>[0-9^1]</code> does <em>not</em> mean “all digits but 1, it means ”all digits plus the caret character plus a 1".</p>
<a href="#finding-0-to-3-white-space-characters-followed-by-an-ascii-letter-at-the-beginning-of-a-line" id="finding-0-to-3-white-space-characters-followed-by-an-ascii-letter-at-the-beginning-of-a-line" class="autoheader_anchor">
<h3>Finding 0 to 3 white space characters followed by an ASCII letter at the beginning of a line</h3>
</a>
<pre><code>      {'^\s{0,3}[a-zA-Z]' ⎕R '⌹' ⊣ ⍵}¨'Zero' ' One' '  Two' '   Three' '    four'
⌹ero  ⌹ne  ⌹wo  ⌹hree      four</code></pre>
<p><code>\s</code> escapes the ASCII letter “s”, meaning that the “s” takes on a special meaning: <code>\s</code> stands for “any whitespace”. That is at the very least the space character (<code>⎕UCS 32</code>) and the tab character (<code>⎕UCS 9</code>). There are two options (the stuff that can be set with the <code>⍠</code> operator) that influence which characters qualifiy as white space:</p>
<ul>
<li>“Mode” (discussed soon).</li>
<li>“UCP”.</li>
</ul>
<a href="#analyzing-apl-code" id="analyzing-apl-code" class="autoheader_anchor">
<h3>Analyzing APL code</h3>
</a>
<p>Let's assume that you want to investigate APL code for a variable name <code>foo</code> but you want text and comments to be ignored. This is our input string:</p>
<pre><code>      is←'a←1 ⋄ foo←1 2 ⋄ txt←''The ⍝ marks a comment; foo'' ⍝ set up vars a, foo, txt'</code></pre>
<p>We want <code>foo←1 2</code> to be found/changed while the text and the comment shall be ignored/remain unchanged. The problem is aggravated by the fact that the text contains a <code>⍝</code> symbol.</p>
<p>The naive approach does not work:</p>
<pre><code>      'foo' ⎕R '⌹' ⊣ is
a←1 ⋄ ⌹←1 2 ⋄ txt←'The ⍝ marks a comment; ⌹' ⍝ set up vars a, ⌹, txt</code></pre>
<p>Dyalog's implementation of regular expressions offers an elegant solution to the problem:</p>
<pre><code>      '''.*''' '⍝\N*$' 'foo'⎕R(,¨'&amp;&amp;⌹')⍠('Greedy' 0)⊣is
a←1 ⋄ ⌹←1 2 ⋄ txt←'The ⍝ marks a comment; foo' ⍝ set up vars a, foo, txt</code></pre>
<p>This needs some explanation:</p>
<ol start="1">
<li><code>\N</code> …   ⍝TODO⍝ !!</li>
<li><code>'''.*'''</code> catches all text, and for that text <code>&amp;</code> is specified as replacement. Now <code>&amp;</code> stands for the matching text, therefore nothing will change at all but the matching text <em>won't participate in any further actions!</em> In other words: everything between quotes is left alone.</li>
<li><code>'⍝.*$'</code> catches everything from a lamp (<code>⍝</code>) to the end of the line (<code>$</code>) and replaces it by itself (<code>&amp;</code>). Again nothing changes but the comment will not be affected by anything that follows. Since the first expression has already masked eveything within (and including) quotes the first <code>⍝</code> does not cause problems.</li>
<li>Finally <code>foo</code> catches the string “foo” in the remaining part, and that is what we are interested in.</li>
</ol>
<p>As a result <code>foo</code> is found within the code but neither within the text nor as part of the comment.</p>
<p>As far as we know this feature is specific to Dyalog, but then we have limited experience with other regular expression engines.</p>
<p>Note that the <code>,¨</code> in <code>,¨'&amp;&amp;⌹'</code> is essential because otherwise ….<code>⍝TODO⍝</code> Bug report &lt;01406&gt;</p>
<p>A&gt; ### Greedy and lazy A&gt; A&gt; Note that using the option (<code>⍠('Greedy' 0)</code>) has a disadvantage: it makes the <em>whole search pattern</em> lazy. There might be cases when you want part of your search pattern to be lazy and other parts greedy. Luckily this can be achieved with the meta character question mark (<code>?</code>): A&gt; A&gt; ~~~ A&gt; '“.<em>?”'⎕R '⌹' ⊣ is A&gt; He said ⌹ and ⌹ A&gt; ~~~ A&gt; A&gt; Since “Greedy” is the engine's default you need to specify the <code>?</code> only for those parts of your search pattern you want to be lazy.</p>
<p>Our search pattern is still not perfect since it would work on <code>boofoogoo</code> as well:</p>
<pre><code>      '''.*''' '⍝.*$' 'foo'⎕R(,¨'&amp;&amp;⌹')⍠('Greedy' 0)⊣'This boofoogoo is found as well'
This boo⌹goo is found as well</code></pre>
<p>To solve this we need to introduce look-ahead and look-behind, together known as look-arounds. The names make it pretty obvious what they do. We want to emphasize that all matching attempts we've introduced so far have been “consuming”. Look-ahead as well as look-behind are <em>not</em> consuming. That means that no matter whether they are successful or not they won't change the position the engine is currently investigating. They are also called zero-length assertions.</p>
<p>However, before we tackle our problem we need to introduce the concept of both word boundaries and anchors. We've already met one anchor: the caret (<code>^</code>), which matches the beginning of a line. There is also the dollar (<code>$</code>) which matches the end of a line. And there is <code>\b</code> which matches a “word boundary”. All these characters are zero-length matches.</p>
<p>I&gt; Depending on the option “Mode” <code>^</code> and <code>$</code> have different meanings. This is discussed soon.</p>
<p>To put it simply, <code>\b</code> allows you to perform a “whole word only” search. Prior to version 8 of PCRE (and 16.0 of Dyalog) this was true only for ASCII characters. Now you can set the “UCP” option to 1 if you want Unicode characters to be taken into account as well:</p>
<pre><code>       ⍴'\bger\b'⎕S 0 ⊣'Kai Jägerßabc'
1
      ⍴'\bger\b'⎕S 0 ⍠('UCP' 1)⊣'Kai Jägerßabc'
0</code></pre>
<p>The following uses both, look-ahead and look-behind for making sure that “ger” stands on its own:</p>
<pre><code>      ss←'ger :ger ger! Jaeger Jägerßabc'
      '(?&lt;=\b)ger(?=\b)'⎕R'⌹' ⊣ ss
⌹ :⌹ ⌹! Jaeger Jä⌹ßabc</code></pre>
<p>Both look-ahead and look behind start with <code>(?</code>. A look behind then needs a <code>&lt;</code> while the look-ahead doesn't. Both then need either a <code>=</code> for “equal” or a <code>!</code> for “not equal” followed by the search token and finally a closing <code>)</code>. Hence <code>(?&lt;=\b)</code> for the look-behind and <code>(?=\b)</code> for the look-ahead.</p>
<p>What the engine does:</p>
<ul>
<li>Since the search pattern starts with a look-behind the engine checks whether there is a word boundary <em>to the left of the current position</em>.</li>
<li>It's the beginning of the line, so that's successful, and the engine then checks whether the current position matches a “g”.</li>
<li>That's successful, so the engine moves forward and tries to match the “e” with the current position.</li>
<li>That's successful too, so the engine moves forward again and tries to match the “r” with the current position.</li>
<li>That a match as well, so the engine performs a look-ahead: <em>without moving forward</em> it tries the match the character <em>after</em> the current one to be a word boundary. A space character qualifies as a word boundary.</li>
<li>Thats a success, too, so the “ger” is replaced by a single <code>⌹</code>.</li>
</ul>
<p>I&gt; What is important to realize is that the current position does not change when a look-behind or a look-ahead is performed; that's why they are called zero-length assertions.</p>
<p>In the same way the following two appearances of “ger” are replaced by <code>⌹</code> because both <code>!</code> and <code>.</code> qualify as word boundaries as well. The “ger” in “Jaeger” was not replaced beecaus the look-behind failed: “e” is not a word boundary. Same for the last one: neither “ä” nor “ß” qualify as word boundaries because they are non-ASCII characters.</p>
<p>That makes word boundaries pretty useless for other languages than English! Luckily with version 16.0 Dyalog was able to start using version 8 of the PCRE engine which now supports the Unicode definition of word boundaries. To take advantage of this feature we have to specify the “UCP” option:</p>
<pre><code>      ss←'ger :ger ger! Jaeger Jägerßabc'
      '(?&lt;=\b)ger(?=\b)'⎕R'⌹' ⍠('UCP' 1) ⊣ ss
⌹ :⌹ ⌹! Jaeger Jägerßabc</code></pre>
<p>Now both “ä” and “ß” qualify as word boundaries.</p>
<p>We can use look-ahead and look-behind to solve a problem we did run into with numbers. This did not really work because <em>all</em> dots got replaced when we wanted only those with digits to the right and the left being a match:</p>
<pre><code>      '[\d.¯-]'⎕R'⌹'⊣'It''s 23.45 plus 99.12.'
It's ⌹⌹⌹⌹⌹ plus ⌹⌹⌹⌹⌹⌹</code></pre>
<p>We don't want the last dot to be a match:</p>
<pre><code>      '\d' '(?&lt;=\d).(?=\d)'⎕R'⌹'⊣'It''s 23.45 plus 99.12.'
It's ⌹⌹⌹⌹⌹ plus ⌹⌹⌹⌹⌹.</code></pre>
<p>That works! We use two expression here: first we look for all digits and then we look for dots that have a digits to their right and their left. However, in case you need <code>⎕S</code> to return the start and the length of any matches then the result is unlikely to be what you are after:</p>
<pre><code>      '\d' '(?&lt;=\d).(?=\d)'⎕S 0 1 ⊣'It''s 23.45 plus 99.12.'
 5 1  6 1  7 1  8 1  9 1  16 1  17 1  18 1  19 1  20 1</code></pre>
<p>We need an expression that identifies any vector of digits as one unit, no matter whether there is a dot between the digits or not:</p>
<pre><code>      '\d+(?&lt;=\d).(?=\d)\d+' ⎕R '⌹' ⊣ 'It''s 23.45 plus 99.12.'
It's ⌹ plus ⌹.
      '\d+(?&lt;=\d).(?=\d)\d+' ⎕S 0 1 ⊣ 'It''s 23.45 plus 99.12.'
 5 5  16 5</code></pre>
<p>That's better.</p>
<p>Naturally you will need a way to <em>negate</em> a look-ahead and a look-behind. That can be achieved by using a <code>!</code> rather than a <code>=</code>.</p>
<p>Lets' repeat this. Assuming we look for “x” and “y”:</p>
<pre><code>      'x(?&lt;=y)' ⎕R'⌹' ⊣ 'abxycxd' ⍝ Exchange all "x" when followed by a "y"
ab⌹ycxd
      'x(?!y)' ⎕R'⌹' ⊣ 'abxycxd' ⍝ Exchange all "x" when NOT followed by a "y"
abxyc⌹d
      '(?&lt;=x)y' ⎕R'⌹' ⊣ 'abxycyd' ⍝ Exchange all "y" when preceeded by an "x"
abx⌹cyd
      '(?&lt;!x)y' ⎕R'⌹' ⊣ 'abxycyd' ⍝ Exchange all "y" when NOT preceeded by an "x"
abxyc⌹d</code></pre>
<a href="#transformation-function" id="transformation-function" class="autoheader_anchor">
<h2>Transformation function</h2>
</a>
<p>Instead of providing a replace string one can also pass a function as operand to <code>⎕R</code>. Our earlier example:</p>
<pre><code>      is←'a←1 ⋄ foo←1 ⋄ txt←''text; foo'' ⍝ comment'</code></pre>
<p>Let's replace just the variable name with something else with a transformation function:</p>
<pre><code>      ∇test[⎕]∇
[0]   r←{x}test y
[1]   .

      '''.*''' '⍝.*$' 'foo'⎕R  test⊣is
SYNTAX ERROR
test[1] .
       ∧
      y.(⊃{⍵ (⍎⍵)}¨↓⎕nl 2 9)
 Block        a←1 ⋄ foo←1 ⋄ txt←'text; foo' ⍝ comment
 BlockNum                                           0
 Lengths                                            3
 Match                                            foo
 Names
 Offsets                                            6
 Pattern                                          foo
 PatternNum                                         2
 ReplaceMode                                        0
 TextOnly                                           0</code></pre>
<p>The right argument contains all the pieces of information that you will possibly need.</p>
<p>We modify <code>test</code> so that is leaves the text and the comment untouched:</p>
<pre><code>      )reset
      ∇test[⎕]∇
[0]   r←{x}test y
[1]   :If ''''''≡2⍴¯1⌽y.Match
[2]       ⎕←r←y.Match
[3]   :ElseIf '⍝'=1⍴y.Match
[4]       ⎕←r←y.Match
[5]   :Else
[6]       r←'⌹Hello world⌹'
[7]   :EndIf

      '''.*''' '⍝.*$' 'foo'⎕R test⊣is
'text; foo'
⍝ comment
a←1 ⋄ ⌹Hello world⌹←1 ⋄ txt←'text; foo' ⍝ comment</code></pre>
<p>Since any match that starts and ends with a quote is text by definition the function returns those untouched. Anything that start with a lamp symbol is a comment, so they are returned untouched as well. That leaves the hits for the real variable names: they are exchanged against <code>⌹Hello world⌹</code>.</p>
<p>Naturally transformation functions gives you enormous power: you can do whatever you like.</p>
<a href="#document-mode" id="document-mode" class="autoheader_anchor">
<h2>Document mode</h2>
</a>
<p>So far we have specified just a simple string as input. We can however pass a vector of strings as well. Look at this example:</p>
<pre><code>      input←'He said: "Yes, that might' 'well be right." She answered: "So be it!"'</code></pre>
<p>It's not a bad idea to think of the two elements of the input vector as “blocks”. Note that the first text spans over both blocks.</p>
<p>By default the search engine operates in “Line” mode. That means that each block is processed independently by the engine. Therefore you cannot search for <code>\r</code> in line mode: the search engine will never see them.</p>
<p>In mixed as well as document mode you <em>can</em> search for <code>\r</code> because all blocks are passed at once. Naturally this also requires more memory than line mode.</p>
<p>Let's do some tests:</p>
<pre><code>      '".*"'⎕R'⌹'⍠('Greedy' 0)⊣input
 He said: "Yes, that might  well be right.⌹So be it!"
      '".*"'⎕R'⌹'⍠('Greedy' 0)('Mode' 'M')('DotAll' 1)⊣input
He said: ⌹ She answered: ⌹</code></pre>
<p>Note that in order to specify <code>('DotAll' 1)</code> it is necessary to set <code>('Mode' 'M')</code>. <code>('Mode' 'D')</code> would have worked in the same way. However, when it comes to <code>^</code> and <code>$</code> then it makes a big difference:</p>
<ul>
<li>In line mode (<code>('Mode' 'L')</code>) <code>^</code> finds the start of the line and <code>$</code> finds the end of the line.</li>
<li>In mixed mode (<code>('Mode' 'M')</code>) <code>^</code> finds the start of each block and <code>$</code> finds the end of each block.</li>
<li>In document mode (<code>('Mode' 'D')</code>) <code>^</code> finds the start of the document and <code>$</code> finds the end of the document.</li>
</ul>
<p>Note that rather than specifying ⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹⌹</p>
<a href="#misc" id="misc" class="autoheader_anchor">
<h2>Misc</h2>
</a>
<a href="#tests" id="tests" class="autoheader_anchor">
<h3>Tests</h3>
</a>
<p>Given that complex regular expressions are hard to read and maintain you should document intensively. The best way to document them is to write exhaustive test cases. Therefore we highly recommond that you write test cases at least for the more complex regular expressions.</p>
<a href="#performance" id="performance" class="autoheader_anchor">
<h3>Performance</h3>
</a>
<p>Don't expect regular expressions to be faster than a taylored APL solutions; instead expect them to be slightly slower.</p>
<p>However, many regular expressions like finding a simple string in another simple string or uppercasing or lowercasing characters are converted by the interpreter into a native (=faster) APL expression (<code>⍷</code> and (<code>⌶ 819</code>).</p>
<a href="#helpful-stuff" id="helpful-stuff" class="autoheader_anchor">
<h3>Helpful stuff</h3>
</a>
<dl>
<dt>RegexBuddy</dt>
<dd>This is a software that helps interpreting (or building) regular expressions.</dd>
<dt><a href="http://www.regular-expressions.info/tutorial.html" class="external_link">http://www.regular-expressions.info/tutorial.html</a></dt>
<dd><p>This is a web site that really goes into the details. It's from the author of RegExBuddy.</p></dd>
<dd><p>The web site also comes with detailed book reviews: <a href="http://www.regular-expressions.info/hipowls.html" class="external_link">http://www.regular-expressions.info/hipowls.html</a></p></dd>
</dl>
</body>
</html>